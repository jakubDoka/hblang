// source code
Point := struct {
	x: int,
	y: int,
}

Brg := struct {
	b: u8,
	g: u8,
	r: u8,
}

FB_WIDTH := 1280
FB_HEIGHT := 720

main := fn(): int {
    back_buffer := create_backbuffer_ptr()
    loop {
        @inline(draw_rect_fill(back_buffer, .(0, 0), .(FB_WIDTH, FB_HEIGHT), .(0, 255, 255)))
        log.info("drew\0")
    }
    return 0
}

draw_rect_fill := fn(buffer: ^u8, pos: Point, tr: Transform, color: Bgr): int {
    n := 0
    loop if n == tr.height * tr.width break else {
        @inline(draw_pixel(buffer, .(n % tr.width + pos.x, n / tr.width + pos.y), color))
        n += 1
    }
    return 0
}

draw_pixel := fn(buffer: ^u8, pos: Point, color: Bgr): int {
    *@as(^Bgr, @bitcast(buffer + @inline(screenidx(pos)))) = color
    return 0
}

screenidx := fn(pos: Point): int {
    return pos.x + (pos.y * FB_WIDTH)
}

// representation

g1: global constant = 1280
g2: global constant = 720
g3: global constant

Point: struct int, int
Bgr: struct u8, u8, u8
Transform: struct int, int

screenidx := fn(pos: Point): int {
	r0:
		v1: field pos 1
		v2: load_global g3
		v3: * v1 v2
		v4: + v3 v1
		ret v4
}

draw_pixel := fn(buffer: ^u8, pos: Point, color: Bgr): int {
	r0:
		v1: inline_call screenidx pos
		v2: + buffer v1
		store v2 color
		v3: 0
		ret v3
}

draw_rect_fill := fn(buffer: ^u8, pos: Point, tr: Transform, color: Bgr): int {
	r0:
		v1: 0
		goto r1(v1)
	r1(v1):
		v2: field tr 0
		v3: field tr 1
		v4: * v2 v3
		v5: == v1 v4
		if v5 r3 r2(v1)
	r2(v1):
		v2: field tr 0
		v3: % v1 v2
		v4: field pos 0
		v5: + v3 v4
		v6: field pos 1
		v7: / v1 v6
		v8: field tr 1
		v9: * v8 v7
		v10: struct Point v5, v9
		_: inline_call draw_pixel buffer, v10, color
		v11: 1
		v12: + v1 v11
		goto r1(v12)
	r3:
		ret v1
}

main := fn(): int {
	r0:
		v1: inline_call create_backbuffer_ptr
		goto r1
	r1:
		v3: 0
		v2: struct Point v3, v3
		v5: load_global g1
		v6: load_global g2
		v4: struct Point v5, v6
		v8: 255
		v7: struct Bgr v3, v8, v8
		_: inline_call draw_rect_fill v1, v2, v7
		call log_info v3
		goto r1
}

// after inlining

main := fn(): int {
	r0:
		v1: call create_backbuffer_ptr
		goto r1
	r1:
		v3: 0
		v2: struct Point v3, v3
		v5: load_global g1
		v6: load_global g2
		v4: struct Transform v5, v6
		v8: 255
		v7: struct Bgr v3, v8, v8
		buffer: v1
		pos: v2
		tr: v4
		color: v7
		v1: 0
		goto r1(v1)
	r2(v1):
		v2: field tr 0
		v3: field tr 1
		v4: * v2 v3
		v5: == v1 v4
		if v5 r3 r2(v1)
	r3(v1):
		v2: field tr 0
		v3: % v1 v2
		v4: field pos 0
		v5: + v3 v4
		v6: field pos 1
		v7: / v1 v6
		v8: field tr 1
		v9: * v8 v7
		v10: struct Point v5, v9
		buffer: buffer
		pos: v10
		color: color
		pos: pos
		v1: field pos 1
		v2: load_global g3
		v3: * v1 v2
		v5: field pos 0
		v4: + v3 v1
		v1: v4
		v2: + buffer v1
		store v2 color
		v11: 1
		v12: + v1 v11
		goto r1(v12)
	r4:
		call log_info v3
		goto r1
}

// eliminate renames + load constant globals

main := fn(): int {
	r0:
		v1: call create_backbuffer_ptr
		goto r1
	r1:
		v3: 0
		v2: struct Point v3, v3
		v5: load_global g1
		v6: load_global g2
		v4: struct Transform v5, v6
		v8: 255
		v7: struct Bgr v3, v8, v8
		v1: 0
		goto r1(v1)
	r2(v1):
		v2: field r1.v4 0
		v3: field r1.v4 1
		v4: * v2 v3
		v5: == v1 v4
		if v5 r3 r2(v1)
	r3(v1):
		v2: field r1.v4 0
		v3: % v1 v2
		v4: field r1.v2 0
		v5: + v3 v4
		v6: field r1.v2 1
		v7: / v1 v6
		v8: field r1.v4 1
		v9: * v8 v7
		v10: struct Point v5, v9
		v1: field v10 1
		v2: load_global g1
		v3: * v1 v2
		v5: field v10 0
		v4: + v3 v1
		v1: v4
		v2: + r1.v1 v1
		store v2 r1.v7
		v11: 1
		v12: + v1 v11
		goto r1(v12)
	r4:
		call log_info v3
		goto r1
}
