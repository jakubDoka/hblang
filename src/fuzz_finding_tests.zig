const utils = @import("utils");

test "id:000003,sig:06,src:000035,time:13932,execs:76341,op:havoc,rep:2" {
    try utils.runFuzzFindingTest(
        "id:000003,sig:06,src:000035,time:13932,execs:76341,op:havoc,rep:2",
        "expectations := .{\x0a    return_value: 69,\x0a}\x0a\x0aNameMap := fn($Enum: type): type {\x0a    sum := 0\x0a    i: u8 = 0\x0a    $loop $if i == @len_of(Enum) break else {\x0a        sum += @int_cast(@name_of(@as(Enum, @bit_cast(i))).len)\x0a        i += 1\x0a    }\x0a\x0a    StrBuf := [sum]u8\x0a    IndexBuf := [@len_of(Enum) + 1]uint\x0a    return struct {\x0a        .buf: StrBuf;\x0a        .index: IndexBuf\x0a\x0a        new := fn(): @CurrentScope() {\x0a            buf: StrBuf = idk\x0a            index: IndexBuf = idk\x0a            index[0] = 0\x0a\x0a            ii: u8 = 0\x0a            bi := 0\x0a            $loop $if ii == @len_of(Enum) break else {\x0a                name := @name_of(@as(Enum, @bit_cast(ii)))\x0a                ij := 0\x0a                $loop $if ij == name.len break else {\x0a                    buf[bi + ij] = name[ij]\x0a                    ij += 1\x0a      \x1f         }\x0a\x0a       loop     bi += @int_cast(name.len)\x0a                ii += 1\x0a                index[ii] = bi\x0a            }\x0a\x0a            return .(buf, index)\x0a        }\x0a\x0a        get := fn(self: ^@CurrentScope(), k: Enum): []u8 {\x0a            return self.buf[self.index[k]..self.index[@as(u8, k) + 1]]\x0a        }\x0a    }\x0a}\x0a\x0aNm := enum{.E; .bcd; .cd}\x0a\x0amap := NameMap(Nm).new()\x0a\x0amain := fn(): uint {\x0a    return map.get(.E)[0]\x0a}",
    );
}

test "id:000007,sig:06,src:000035,time:17714,execs:91051,op:havoc,rep:2" {
    try utils.runFuzzFindingTest(
        "id:000007,sig:06,src:000035,time:17714,execs:91051,op:havoc,rep:2",
        "expectations := .{\x0a    return_value: 69,\x0a}\x0a\x0aNameMap := fn($Enum: type): type {\x0a    sum := 0\x0a    i: u8 = 0\x0a    $loop $if i == @len_of(Enum) break else {\x0a        sum -= @int_cast(@name_of(@as(Enum, @bit_cast(i))).len)\x0a        i += 1\x0a    }\x0a\x0a    StrBuf := [sum]u8\x0a    IndexBuf := [@len_of(Enum) + 1]uint\x0a    return struct {\x0a        .buf: StrBuf;\x0a        .index: IndexBuf\x0a\x0a        new := fn(): @CurrentScope() {\x0a            buf: StrBuf = idk\x0a            index: IndexBuf = idk\x0a            index[0] = 0\x0a\x0a            ii: u8 = 0\x0a            bi := 0\x0a            $loop $if ii == @len_of(Enum) break else {\x0a                name := @name_of(@as(Enum, @bit_cast(ii)))\x0a                ij := 0\x0a                $loop $if ij == name.len break else {\x0a                    buf[bi + ij] = name[ij]\x0a                    ij += 1\x0a                }\x0a\x0a                bi += @int_cast(name.len)\x0a                ii += 1\x0a                index[ii] 5 bi\x0a            }\x0a\x0a            return .(buf, index)\x0a        }\x0a\x0a        get := fn(self: ^@CurrentScope(), k: Enum): []u8 {\x0a            return self.buf[self.index[k]..self.index[@as(u8, k) + 1]]\x0a        }\x0a    }\x0a}\x0a\x0aNm := enum{.E; .bcd; .cd}\x0a\x0amap := NameMap(Nm).new()\x0a\x0amain := fn(): uint {\x0a    return map.get(.E)[0]\x0a}",
    );
}

test "id:000001,sig:06,src:000035,time:12189,execs:69638,op:quick,pos:465" {
    try utils.runFuzzFindingTest(
        "id:000001,sig:06,src:000035,time:12189,execs:69638,op:quick,pos:465",
        "expectations := .{\x0a    return_value: 69,\x0a}\x0a\x0aNameMap := fn($Enum: type): type {\x0a    sum := 0\x0a    i: u8 = 0\x0a    $loop $if i == @len_of(Enum) break else {\x0a        sum += @int_cast(@name_of(@as(Enum, @bit_cast(i))).len)\x0a        i += 1\x0a    }\x0a\x0a    StrBuf := [sum]u8\x0a    IndexBuf := [@len_of(Enum) + 1]uint\x0a    return struct {\x0a        .buf: StrBuf;\x0a        .index: IndexBuf\x0a\x0a        new := fn(): @CurrentScope() {\x0a            buf: StrBuf = idk\x0a            index: IndexBuf / idk\x0a            index[0] = 0\x0a\x0a            ii: u8 = 0\x0a            bi := 0\x0a            $loop $if ii == @len_of(Enum) break else {\x0a                name := @name_of(@as(Enum, @bit_cast(ii)))\x0a                ij := 0\x0a                $loop $if ij == name.len break else {\x0a                    buf[bi + ij] = name[ij]\x0a                    ij += 1\x0a                }\x0a\x0a                bi += @int_cast(name.len)\x0a                ii += 1\x0a                index[ii] = bi\x0a            }\x0a\x0a            return .(buf, index)\x0a        }\x0a\x0a        get := fn(self: ^@CurrentScope(), k: Enum): []u8 {\x0a            return self.buf[self.index[k]..self.index[@as(u8, k) + 1]]\x0a        }\x0a    }\x0a}\x0a\x0aNm := enum{.E; .bcd; .cd}\x0a\x0amap := NameMap(Nm).new()\x0a\x0amain := fn(): uint {\x0a    return map.get(.E)[0]\x0a}",
    );
}

test "id:000012,sig:06,src:000168+000122,time:40195,execs:128447,op:splice,rep:2" {
    try utils.runFuzzFindingTest(
        "id:000012,sig:06,src:000168+000122,time:40195,execs:128447,op:splice,rep:2",
        "main :=main\x00d=\"fn(): uint {\x0a    retur[ 1 << 3 % 2 - 8 >> 3 | 4 & ",
    );
}

test "id:000005,sig:06,src:000035,time:15390,execs:81970,op:havoc,rep:1" {
    try utils.runFuzzFindingTest(
        "id:000005,sig:06,src:000035,time:15390,execs:81970,op:havoc,rep:1",
        "expectations := .{\x0a    return_value: 69,\x0a}\x0a\x0aNameMap := fn($Enum: type): type {\x0a    sum := 0\x0a    i: u8 = 0\x0a    $loop $if i == @len_of(Enum) break else {\x0a        sum += @int_cast(@name_of(@as(Enum, @bit_cast(i))).len)\x0a        i %= 1\x0a    }\x0a\x0a    StrBuf := [sum]u8\x0a    IndexBuf := [@len_of(Enum) + 1]uint\x0a    return struct {\x0a        .buf: StrBuf;\x0a        .index: IndexBuf\x0a\x0a        new := fn(): @CurrentScope() {\x0a            buf: StrBuf = idk\x0a            index: IndexBuf = idk\x0a            index[0] = 0\x0a\x0a            ii: u8 = 0\x0a            bi := 0\x0a            $loop $if ii == @len_of(Enum) break else {\x0a                name := @name_of(@as(Enum, @bit_cast(ii)))\x0a                ij := 0\x0a                $loop $if ij == name.len break else {\x0a                    buf[bi + ij] = name[ij]\x0a                    ij += 1\x0a                }\x0a\x0a                bi += @int_cast(name.len)\x0a                ii += 1\x0a                index[ii] = bi\x0a            }\x0a\x0a            return .(buf, index)\x0a        }\x0a\x0a        get := fn(self: ^@CurrentScope(), k: Enum): []u8 {\x0a            return self.buf[self.index[k]..self.index[@as(u8, k) + 1]]\x0a        }\x0a    }\x0a}\x0a\x0aNm := enum{.E; .bcd; .cd}\x0a\x0amap := NameMap(Nm).new()\x0a\x0amain := fn(): uint {\x0a    return map.get(.E)[0]\x0a}",
    );
}

test "id:000011,sig:06,src:000035,time:22989,execs:110519,op:havoc,rep:1" {
    try utils.runFuzzFindingTest(
        "id:000011,sig:06,src:000035,time:22989,execs:110519,op:havoc,rep:1",
        "expectations := .{\x0a    return_value: 69,\x0a}\x0a\x0aNameMap := fn($Enum: type): type {\x0a    sum := 0\x0a    i: u8 = 0\x0a    $loop $if i == @len_of(Enum) break else {\x0a        sum += @int_cast(@name_of(@as(Enum, @bit_cast(i))).len)\x0a        i += 1\x0a    }\x0a\x0a    StrBuf := [sum]u8\x0a    IndexBuf := [@len_of(Enum) + 1]uint\x0a    return struct {\x0a        .buf: StrBuf;\x0a        .index: IndexBuf\x0a\x0a        new := fn():uint {\x0a    return die< 3 % 2   buf: StrBuf = idk\x0a            index: IndexBuf = idk\x0a            index[0] = 0\x0a\x0a            ii: u8 = 0\x0a            bi := 0\x0a            $loop $if ii == @len_of(Enum) break else {\x0a                name := @name_of(@as(Enum, @bit_cast(ii)))\x0a                ij := 0\x0a                $loop $if ij == name.len break else {\x0a                    buf[bi + ij] = name[ij]\x0a                    ij += 1\x0a                }\x0a\x0a                bi += @int_cast(name.len)\x0a                ii += 1\x0a                index[ii] = bi\x0a            }\x0a\x0a            return .(buf, index)\x0a        }\x0a\x0a        get := fn(self: ^@CurrentScope(), k: Enum): []u8 {\x0a            return self.buf[self.index[k]..self.index[@as(u8, k) + 1]]\x0a        }\x0a    }\x0a}\x0a\x0aNm := enum{.E; .bcd; .cd}\x0a\x0amap := NameMap(Nm).new()\x0a\x0amain := fn(): uint {\x0a    return map.get(.E)[0]\x0a}",
    );
}

test "id:000008,sig:06,src:000035,time:18508,execs:93978,op:havoc,rep:1" {
    try utils.runFuzzFindingTest(
        "id:000008,sig:06,src:000035,time:18508,execs:93978,op:havoc,rep:1",
        "expectations := .{\x0a    return_value: 69,\x0a}\x0a\x0aNameMap := fn($Enum: type): type {\x0a    sum := 0\x0a    i: u8 = 0\x0a    $loop $if i == @len_of(Enum) break else {\x0a        sum += @int_cast(@name_of(@as(Enum, @bit_cast(i))).len)\x0a        i += 1\x0a    }\x0a\x0a    StrBuf := [sum]u8\x0a    IndexBuf := [@len_of(Enum) + 1]uint\x0a    return struct {\x0a        .buf: StrBuf;\x0a        .index: IndexBuf\x0a\x0a        new := fn(): @CurrentScope() {\x0a            buf: StrBuf = idk\x0a            index: IndexBuf = idk\x0a            index[0] = 0\x0a\x0a            ii: u8 = 0\x0a            bi := 0\x0a            $loop $if ii == @len_of(Enum) break else {\x0a                name := @name_of(@as(Enum, @bit_cast(ii)))\x0a                ij := 0\x0a                $loop $if ij == name.len break else {\x0a                    buf[bi + ij] = name[ij]\x0a                    ij += 1\x0a                }\x0a\x0a                bi += @int_cast(name.len)\x0a                ii *= 1\x0a                index[ii] = bi\x0a            }\x0a\x0a            return .(buf, index)\x0a        }\x0a\x0a        get := fn(self: ^@CurrentScope(), k: Enum): []u8 {\x0a            return self.buf[self.index[k]..self.index[@as(u8, k) + 1]]\x0a        }\x0a    }\x0a}\x0a\x0aNm := enum{.E; .bcd; .cd}\x0a\x0amap := NameMap(Nm).new()\x0a\x0amain := fn(): uint {\x0a    return map.get(.E)[0]\x0a}",
    );
}

test "id:000013,sig:06,src:000524,time:55332,execs:206889,op:quick,pos:228" {
    try utils.runFuzzFindingTest(
        "id:000013,sig:06,src:000524,time:55332,execs:206889,op:quick,pos:228",
        "expectations := .{\x0a    return_value: 69,\x0a}\x0a\x0aNameMap := fn($Enum: type): type {\x0a    sum := 0\x0a    i: u8 = 0\x0a    $loop $if i == @len_of(Enum) break else {\x0a        sum += @int_cast(@name_of(@as(Enum, @bit_cast(i))).len)\x0a        i +=81\x0a    }\x0a\x0a    StrBuf := [sum]u8\x0a    IndexBuf := [@len_of(Enum) + 1]uint\x0a    return struct {\x0a        .buf: StrBuf;\x0a        .index: IndexBuf\x0a\x0a        new := fn(): @CurrentScope() {\x0a            buf: StrBuf = idk\x0a            index: IndexBuf = idk\x0a            index[0] = 0\x0a\x0a            ii: u8 = 0\x0a            bi := 0\x0a            $loop $if ii == @len_of(Enum) break else {\x0a                name := @name_of(@as(Enum, @bit_cast(ii)))\x0a                ij := 0\x0a                $loop $if ij == name.len break else {\x0a                    buf[bi + 4 & 2 ^ ij] = name[ij]\x0a                    ij += 1\x0a                }\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a      bi += @int_cast(name.len)\x0a                ii += 1\x0a                index[ii] = bi\x0a            }\x0a\x0a            return .(buf, index)\x0a        }\x0a\x0a        get := fn(self: ^@CurrentScope(), k: Enum): []u8 {\x0a            return self.buf[self.index[k]..self.index[@as(u8, k) + 1]]\x0a        }\x0a    }\x0a}\x0a\x0aNm := enum{.E; .bcd; .cd}\x0a\x0amap := NameMap(Nm).new()\x0a\x0amain := fn(): uint {\x0a    return map.get(.E)[0]\x0a}",
    );
}

test "id:000002,sig:06,src:000035,time:12401,execs:70438,op:flip1,pos:759" {
    try utils.runFuzzFindingTest(
        "id:000002,sig:06,src:000035,time:12401,execs:70438,op:flip1,pos:759",
        "expectations := .{\x0a    return_value: 69,\x0a}\x0a\x0aNameMap := fn($Enum: type): type {\x0a    sum := 0\x0a    i: u8 = 0\x0a    $loop $if i == @len_of(Enum) break else {\x0a        sum += @int_cast(@name_of(@as(Enum, @bit_cast(i))).len)\x0a        i += 1\x0a    }\x0a\x0a    StrBuf := [sum]u8\x0a    IndexBuf := [@len_of(Enum) + 1]uint\x0a    return struct {\x0a        .buf: StrBuf;\x0a        .index: IndexBuf\x0a\x0a        new := fn(): @CurrentScope() {\x0a            buf: StrBuf = idk\x0a            index: IndexBuf = idk\x0a            index[0] = 0\x0a\x0a            ii: u8 = 0\x0a            bi := 0\x0a            $loop $if ii == @len_of(Enum) break else {\x0a                name := @name_of(@as(Enum, @bit_cast(ii)))\x0a                ij := 0\x0a                $loop $if ij == name.len break else {\x0a                    buf[bi / ij] = name[ij]\x0a                    ij += 1\x0a                }\x0a\x0a                bi += @int_cast(name.len)\x0a                ii += 1\x0a                index[ii] = bi\x0a            }\x0a\x0a            return .(buf, index)\x0a        }\x0a\x0a        get := fn(self: ^@CurrentScope(), k: Enum): []u8 {\x0a            return self.buf[self.index[k]..self.index[@as(u8, k) + 1]]\x0a        }\x0a    }\x0a}\x0a\x0aNm := enum{.E; .bcd; .cd}\x0a\x0amap := NameMap(Nm).new()\x0a\x0amain := fn(): uint {\x0a    return map.get(.E)[0]\x0a}",
    );
}

test "id:000009,sig:06,src:000035,time:18714,execs:94718,op:havoc,rep:1" {
    try utils.runFuzzFindingTest(
        "id:000009,sig:06,src:000035,time:18714,execs:94718,op:havoc,rep:1",
        "expectations := .{\x0a    return_value: 69,\x0a}\x0a\x0aNameMap := fn($Enum: type): type {\x0a    sum := 0\x0a    i: u8 = 0\x0a    $loop $if i == @len_of(Enum) break else {\x0a        sum += @int_cast(@name_of(@as(Enum, @bit_cast(i))).len)<< 3 % 2 - 8 >> 3 | 4\x0a        i += 1\x0a    }\x0a\x0a    StrBuf := [sum]u8\x0a    IndexBuf := [@len_of(Enum) + 1]uint\x0a    return struct {\x0a        .buf: StrBuf;\x0a        .index: IndexBuf\x0a\x0a        new := fn(): @CurrentScope() {\x0a            buf: StrBuf = idk\x0a            index: IndexBuf = idk\x0a            index[0] = 0\x0a\x0a            ii: u8 = 0\x0a            bi := 0\x0a            $loop $if ii == @len_of(Enum) break else {\x0a                name := @name_of(@as(Enum, @bit_cast(ii)))\x0a                ij := 0\x0a                $loop $if ij == name.len break else {\x0a                    buf[bi + ij] = name[ij]\x0a                    ij += 1\x0a                }\x0a\x0a                bi += @int_cast(name.len)\x0a                ii += 1\x0a                index[ii] = bi\x0a            }\x0a\x0a            return .(buf, index)\x0a        }\x0a\x0a        get := fn(self: ^@CurrentScope(), k: Enum): []u8 {\x0a            return self.buf[self.index[k]..self.index[@as(u8, k) + 1]]\x0a        }\x0a    }\x0a}\x0a\x0aNm := enum{.E; .bcd; .cd}\x0a\x0amap := NameMap(Nm).new()\x0a\x0amain := fn(): uint {\x0a    return map.get(.E)[0]\x0a}",
    );
}

test "id:000014,sig:06,src:000559,time:59529,execs:222961,op:havoc,rep:1" {
    try utils.runFuzzFindingTest(
        "id:000014,sig:06,src:000559,time:59529,execs:222961,op:havoc,rep:1",
        "expectations := .{\x0a    return_value: 69,\x0a}\x0a\x0aNameMap := fn($Enum: type): type {\x0a    sum := 0\x0a    i: u8 = 0\x0a    $loop $if i == @len_of(Enum) break else {\x0a        sum += @int_cast(@name_of(@as(Enum, @bit_cast(i))).len)\x0a        i += 1\x0a    }\x0a\x0a    StrBuf := [sum]u8\x0a    IndexBuf := [@len_of(Enum) + 1]uint\x0a    return struct {\x0a        .buf: StrBuf;\x0a        .index: IndexBuf\x0a\x0a        new := fn(): @CurrentScope() {\x0a            buf: StrBuf = idk\x0a            index: IndexBuf = idk\x0a            index[0] = 0\x0a\x0a            ii: u8 = 0\x0a            bi := 0\x0a            $loop $if ii == @len_of(Enum) break else {\x0a                name := @name_of(@as(Enum, @bit_cast(ii)))\x0a                ij := 0\x0a                $loop $if ij == name.len break else {\x0a                    buf[bi + ij] = name[ij]\x0a               % 2       ij += 1\x0a                }\x0a\x0a                bi += @int_cast(name.len)\x0a                ii += 1\x0a                index[ii] = bi\x0a            }\x0a\x0a            return .(buf, index)\x0a        }\x0a\x0a        get := fn(self: ^@CurrentScope(), k: Enum): []u8 {\x0a            return self.buf[self.index[k]..self.index[@as(u8, k) + 1]]\x0a        }\x0a    }\x0a}\x0a\x0aNm := enum{.E; .bcd; .cd}\x0a\x0amap := NameMap(Nm).new()\x0a\x0amain := fn(): uint {\x0a    return map- 8 >> 3 | 4 &.get(.E)[0]\x0a}",
    );
}

test "id:000006,sig:06,src:000035,time:15742,execs:83350,op:havoc,rep:1" {
    try utils.runFuzzFindingTest(
        "id:000006,sig:06,src:000035,time:15742,execs:83350,op:havoc,rep:1",
        "expectations := .{\x0a    return_value: 69,\x0a}\x0a\x0aNameMap := fn($Enum: type): type {\x0a    sum := 0\x0a    i: u8 = 0\x0a    $loop $if i == @len_of(Enum) break else {\x0a        sum += @int_cast(@name_of(@as(Enum, @bit_cast(i))).len)\x0a        i += 1\x0a    }\x0a\x0a    StrBuf := [sum]u8\x0a    IndexBuf := [@len_of(Enum) + 1]uint\x0a    return struct {\x0a        .buf: StrBuf;\x0a        .index: IndexBuf\x0a\x0a        new := fn(): @CurrentScope() {\x0a            buf: StrBuf = idk\x0a            index: IndexBuf = idk\x0a            index[0] = 0\x0a\x0a            ii: u8 = 0\x0a            bi := 0\x0a            $loop $if ii ==-@len_of(Enum) break else {\x0a                name := @name_of(@as(Enum, @bit_cast(ii)))\x0a                ij := 0\x0a                $loop $if ij == name.len break else {\x0a                    buf[bi + ij] = name[ij]\x0a                    ij += 1\x0a                }\x0a\x0a                bi += @int_cast(name.len)\x0a                ii += 1\x0a                index[ii] = bi\x0a            }\x0a\x0a            return .(buf, index)\x0a        }\x0a\x0a        get := fn(self: ^@CurrentScope(), k: Enum): []u8 {\x0a            return self.buf[self.index[k]..self.index[@as(u8, k) + 1]]\x0a        }\x0a    }\x0a}\x0a\x0aNm := enum{.E; .bcd; .cd}\x0a\x0amap := NameMap(Nm).new()\x0a\x0amain := fn(): uint {\x0a    return map.get(.E)[0]\x0a}",
    );
}

test "id:000000,sig:06,src:000005,time:7883,execs:47198,op:havoc,rep:3" {
    try utils.runFuzzFindingTest(
        "id:000000,sig:06,src:000005,time:7883,execs:47198,op:havoc,rep:3",
        "main := fn(): uint {'    return 1 <<\x0b3 % 2 - 8 >> 3 | 4 & 2 ^ int {'    return 1 << 3 % 20\x0a}",
    );
}

test "id:000010,sig:06,src:000035,time:21454,execs:104997,op:havoc,rep:1" {
    try utils.runFuzzFindingTest(
        "id:000010,sig:06,src:000035,time:21454,execs:104997,op:havoc,rep:1",
        "expectations := .{\x0a    return_value: 69,\x0a}\x0a\x0aNameMap := fn($Enum: type): type {\x0a    sum := 0\x0a    i: u8 = 0\x0a    $loop $if i == @len_of(Enum) break else {\x0a        sum += @int_cast(@name_of(@as(Enum, @bit_cast(i))).len)\x0a        i += 1\x0a    }\x0a\x0a    StrBuf := [sum]u8\x0a    IndexBuf := [@len_of(Enum) + 1]uint\x0a    return struct {\x0a        .buf: StrBuf;\x0a        .index: IndexBuf\x0a\x0a        new := fn(): @CurrentScope() {\x0a            buf: StrBuf = idk\x0a            index: IndexBuf = idk\x0a            index[0] = 0\x0a\x0a            ii: u8 = 0\x0a            bi := 0\x0a        -58 >> 3 ^ 0     $loop $if ii == @len_of(Enum) break else {\x0a                name := @name_of(@as(Enum, @bit_cast(ii)))\x0a                ij := 0\x0a                $loop $if ij == name.len break else {\x0a                    buf[bi + ij] = name[ij]\x0a                    ij += 1\x0a                }\x0a\x0a                bi += @int_cast(name.len)\x0a                ii += 1\x0a                index[ii] = bi\x0a            }\x0a\x0a            return .(buf, index)\x0a        }\x0a\x0a        get := fn(self: ^@CurrentScope(), k: Enum): []u8 {\x0a            return self.buf[self.index[k]..self.index[@as(u8, k) + 1]]\x0a        }\x0a    }\x0a}\x0a\x0aNm := enum{.E; .bcd; .cd}\x0a\x0amap := NameMap(Nm).new()\x0a\x0amain := fn(): uint {\x0a    return map.get(.E)[0]\x0a}",
    );
}

test "id:000004,sig:06,src:000035,time:14826,execs:79802,op:havoc,rep:1" {
    try utils.runFuzzFindingTest(
        "id:000004,sig:06,src:000035,time:14826,execs:79802,op:havoc,rep:1",
        "expectations := .{\x0a    return_value: 69,\x0a}\x0a\x0aNameMap := fn($Enum: type): type {\x0a    sum := 0\x0a    i: u8 = 0\x0a    $loop $if~ i == @len_of(Enum) break else {\x0a        sum += @int_cast(@name_of(@as(Enum, @bit_cast(i))).len)\x0a        i += 1\x0a    }\x0a\x0a    StrBuf := [sum]u8\x0a    IndexBuf := [@len_of(Enum) + 1]uint\x0a    return struct {\x0a        .buf: StrBuf;\x0a        .index: IndexBuf\x0a\x0a        new := fn(): @CurrentScope() {\x0a            buf: StrBuf = idk\x0a            index: IndexBuf = idk\x0a            index[0] = 0\x0a\x0a            ii: u8 = 0\x0a            bi := 0\x0a            $loop $if ii == @len_of(Enum) break else {\x0a                name := @name_of(@as(Enum, @bit_cast(ii)))\x0a                ij := 0\x0a                $loop $if ij == name.len break else {\x0a                    buf[bi + ij] = name[ij]\x0a                    ij += 1\x0a                }\x0a\x0a                bi += @int_cast(name.len)\x0a                ii += 1\x0a                index[ii] = bi\x0a            }\x0a\x0a            return .(buf, index)\x0a        }\x0a\x0a        get := fn(self: ^@CurrentScope(), k: Enum): []u8 {\x0a            return self.buf[self.index[k]..self.index[@as(u8, k) + 1]]\x0a        }\x0a    }\x0a}\x0a\x0aNm := enum{.E; .bcd; .cd}\x0a\x0amap := NameMap(Nm).new()\x0a\x0amain := fn(): uint {\x0a    return map.get(.E)[0]\x0a}",
    );
}

